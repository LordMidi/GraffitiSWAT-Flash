package com.lessrain.project.model {	import com.lessrain.project.view.utils.Encrypt;	import se.cambiata.utils.crypt.Simplecrypt;	import com.adobe.serialization.json.JSON;	import com.lessrain.project.model.vo.SurfaceData;	import com.lessrain.project.view.utils.LessMath;	import org.puremvc.as3.multicore.patterns.proxy.Proxy;	import flash.events.Event;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLRequestMethod;	import flash.net.URLVariables;	import flash.utils.getQualifiedClassName;	/**	 * @author torstenhartel	 */	public class SurfacesProxy extends Proxy {		public static const NAME : String = getQualifiedClassName(SurfacesProxy);		public static const SURFACES_LOAD : String = "surfacesLoad";		public static const SURFACES_LOADED : String = "surfacesLoaded";		public static const TYPE_SUCCESS : String = "typeSuccess";		public static const TYPE_FAILURE : String = "typeFailure";		private var _src : String;		private var _facebookId : String;		private var _xmlData : *;		private var _key : String;		public function SurfacesProxy(fadebookId_ : String) {			_facebookId = fadebookId_;			super(NAME);		}		public function load() : void {			getValidSurfaces();		}		private function handleLoadComplete(data_ : *) : void {			_xmlData = data_;			getValidSurfaces();		}		private function getValidSurfaces() : void {			var request : URLRequest = new URLRequest("php/action/secure/x5Bf9KoNiSii.php");			request.method = URLRequestMethod.POST;			var variables : URLVariables = new URLVariables();						_key = Encrypt.createRandomKey(LessMath.rand(5, 10));			variables.fbid = _facebookId;			variables.gid = _key;			request.data = variables;			var loader : URLLoader = new URLLoader(request);			loader.addEventListener(Event.COMPLETE, onComplete);//			loader.dataFormat = URLLoaderDataFormat.TEXT;			loader.load(request);		}		private function onComplete(event : Event) : void {//			_key = '123456x';			var encoded:String = String(event.target.data);			var jsonString : String = Simplecrypt.decrypt(encoded,_key);			var allTrains : Object;			try {				allTrains = JSON.decode(jsonString);			} catch(e : Error) {				// TODO REMOVE!!!!				jsonString = '{"1":{"key":"electric","name":"Airport Shuttle","price":"10","bought":"true"}}';//				jsonString = '{}';				allTrains = JSON.decode(jsonString);				//TODO throw visible error			}			data = new Vector.<SurfaceData>();			var xml : XML = new XML(_xmlData);			for (var id : String in allTrains) {				var item : SurfaceData = new SurfaceData();				item.dbid = int(id);				item.key = allTrains[id]['key'];//				Debug.trace('SurfacesProxy::onComplete: make ' + item.key);				item.title = allTrains[id]['name'];				item.price = Number(allTrains[id]['price']);				item.bought = allTrains[id]['bought'] == "true";//				Debug.trace('SurfacesProxy::onComplete: ' + item.key + ' costs ' + item.price);				data.push(item);			}			data.sort(sortOnId);			checkComplete();		}				private function sortOnId(a : SurfaceData, b : SurfaceData) : int {			var aId : int = a.dbid;			var bId : int = b.dbid;			if (aId > bId) {				return -1;			} else if (aId < bId) {				return 1;			} else {				return 0;			}		}		private function checkComplete() : void {			if (data) {				sendNotification(SURFACES_LOADED, data, TYPE_SUCCESS);			} else {				sendNotification(SURFACES_LOADED, null, TYPE_FAILURE);			}		}		override public function onRegister() : void {		}		override public function onRemove() : void {		}		protected function get datas() : Vector.<SurfaceData> {			return data as Vector.<SurfaceData>;		}		public function set src(src : String) : void {			_src = src;		}	}}