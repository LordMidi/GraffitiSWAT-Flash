package com.lessrain.project.view.components.sound {	import com.lessrain.project.ApplicationFacade;	import flash.events.Event;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.utils.getTimer;	/**	 * @author patrickjuchli	 */	public class AssetSound implements IGroupableSound {		// When true, you can't play several voices of the same sound at the same time.		// If you call play while it's playing the current SoundChannel is stopped.		public var forceSingleChannel:Boolean = false;				// Re-Playing the sound is locked for n milliseconds after calling play()		public var timeLockDuration:int = 0;				// Call this function when the sound is complete (Event.SOUND_COMPLETE)		public var onComplete:Function;				protected var _id:String;		protected var _soundGroup:SoundGroup;		protected var _sound:Sound;		protected var _soundTransform:SoundTransform;		protected var _soundChannel:SoundChannel;		protected var _timeLastPlayBegin:int = 0;				public function AssetSound(id:String, soundGroup:SoundGroup = null, initialVolume:Number = 1, initialPan:Number = 0) {															// Fetch the sound from SWFAsset			var swfAsset:Sound = ApplicationFacade.getSWFAssetInstance(id) as Sound;			if (!swfAsset) {				return;				}			_sound = swfAsset;			_id = id;						// Setup the SoundTransform			_soundTransform = new SoundTransform(initialVolume, initialPan);						// Every sound can be part of a SoundGroup			if (soundGroup){				_soundGroup = soundGroup;				_soundGroup.registerSound(this);			}		}		public function dispose():void {						if (_soundGroup) {				_soundGroup.unregisterSound(this);				_soundGroup = null;			}						stop();			_sound = null;			_soundTransform = null;		}				public function get id():String {			return _id;		}						public function play(startTime:Number = 0, loops:int = 0):void {										// Abort, if this play request is to early after the last play request			var timeNow:int = getTimer();			if (timeNow - _timeLastPlayBegin < timeLockDuration) return;			_timeLastPlayBegin = timeNow;//			LogManager.debug('AssetSound.play :: '+_id);			// If only a single channel is allowed stop playing the current one			if (isPlaying) {					if (forceSingleChannel) stop();				else _soundChannel.removeEventListener(Event.SOUND_COMPLETE, onSoundComplete);			}						_soundChannel = _sound.play(startTime, loops, _soundTransform);			_soundChannel.addEventListener(Event.SOUND_COMPLETE, onSoundComplete);		}				public function stop():void {			if (_soundChannel) {				_soundChannel.removeEventListener(Event.SOUND_COMPLETE, onSoundComplete);				_soundChannel.stop();				_soundChannel = null;			}		}				public function get length():Number {			return _sound.length;		}				public function get isPlaying():Boolean {			return (_soundChannel != null);			}				public function setVolumeAndPan(volume:Number, pan:Number):void {			if (_soundTransform) {				_soundTransform.volume = volume;				_soundTransform.pan = pan;				if (_soundChannel) _soundChannel.soundTransform = _soundTransform;			}			}				public function set volume(volume:Number):void {				_soundTransform.volume = volume;			if (_soundChannel) _soundChannel.soundTransform = _soundTransform;		}				public function get volume():Number {			return _soundTransform.volume;		}				public function set pan(amount:Number):void {			_soundTransform.pan = amount;			if (_soundChannel) _soundChannel.soundTransform = _soundTransform;				}				public function get pan():Number {			return _soundTransform.pan;			}				protected function onSoundComplete(event:Event):void {						_soundChannel.removeEventListener(Event.SOUND_COMPLETE, onSoundComplete);			_soundChannel = null;			if (onComplete != null) onComplete();		}				public function get soundChannel() : SoundChannel {			return _soundChannel;		}			}}